Linux is widely adopted as a desktop and server OS because of its high reliability and security. In this topic, you will identify fundamentals of Linux shells, commands, and file system principles to prepare you to support organizations and networks with diverse OS environments.

# Shells, Terminals, and Consoles
----

The kernel is the software component that provides the core set of operating system functions. These include features for managing system hardware and for communicating between software and hardware. A distribution or distro is the Linux kernel plus a distinctive type of package manager and software repository with a selection of customizable shells, utilities, and applications. Distros also have either community-supported or commercial licensing and support options.

### Shells and Terminals

The shell provides a command environment by which a user can operate the OS and applications. Many shell programs are available to use with Linux, notably Bash, zsh, and ksh (Korn shell). These shells expose the same core command set but are distinguished by support for features such as command history, tab completion, command spelling correction, or syntax highlighting.

Many Linux distros are deployed with no desktop environment. The boot process launches a terminal user interface connected to the default shell command interpreter. The terminal and shell are connected by a teletype (tty) device that handles text input and output in separate streams:

- stdin (0) takes the user’s keyboard input and writes it as data to the tty device for processing by the shell’s command interpreter.
- stdout (1) reads data generated by the shell from the tty device and displays it through the terminal.
- stderr (2) carries error information.

Working at a terminal is referred to as using a shell interactively. Non-interactive use means the shell reads commands from a script file.

### Desktop Environments

Linux distros designed for use as client PCs typically load a graphical desktop environment at startup. The graphical environment is driven by an open-source version of the X Window Display system called Xorg (or just X). Various desktop programs can be launched within X. Examples include Gnome (GNU Object Model Environment), KDE (K Desktop Environment), Cinammon, and Xfce.

	GNU is a recursive acronym standing for "GNU is Not UNIX." Many of the non-kernel bits of software developed under the open-source GNU license to replace their proprietary UNIX equivalents can be used with Linux.

![](Meta/Pasted%20image%2020231020184007.png)

Within a desktop environment, you can open a terminal emulator to use the default command shell (or an alternative shell if needed). The terminal emulator runs within a window on the desktop. The terminal emulator connects to the shell via a pseudoterminal (pty/pts) interface.

### Console Switching

When a graphical environment is installed, the X server occupies one of several virtual tty consoles, typically tty1. The **CTRL+ALT+F****_x_** keys can be used to switch between consoles. Each console can support a different login prompt and shell.

# Command Interface
----

Linux **commands** are entered in a standard format:

- The first "word" input is interpreted as the command. This could be a full or relative path to the executable or just the name of an executable stored in a directory identified by a PATH environment variable. The command word is completed by the first space character.
- Options (switches) are used to change the operation of a command. An option can be a single letter (preceded by a single hyphen) or a word (preceded by a double hyphen). The order in which the options are placed on the command is not important.
- Arguments are values supplied to the command for it to operate on, such as file names. Arguments must be supplied in the correct order for the command's syntax.

You can send or redirect the results of one command to another command using a pipe. The pipe symbol is a vertical bar ( | ), which you type between two commands.

You can issue more than one command on a single line by placing a semicolon ( ; ) between the commands. When you press **ENTER**, the commands execute sequentially.

### Case Sensitivity

Commands, parameters, and file and directory names are all case sensitive in Linux. For example, ls -l file.data and ls -L File.data would produce completely different results. Using capitals in the command name would generate an error message.

### Help System

A Linux command reports its function and syntax when executed with the `--help` option. The help is often several pages long so it common to pipe the output to the more command. more shows the results a page at a time. For example: `ls --help | more`

Alternatively, you can use man to view the help pages for a particular command. For example, use `man man` to view the help pages for the man command!

Also note that terminal emulators typically support **TAB** completion to help in entering commands. Use the **UP** and **DOWN** arrow keys to scroll through command history. In some terminals, you can use **SHIFT+PAGEUP** or **SHIFT+PAGEDOWN** and **CTRL+SHIFT+UPARROW** or **CTRL+SHIFT+DOWNARROW** to scroll through output. 

### File Editors

Most Linux files use a plain text format and can easily be edited directly. There are numerous text file editors. The **Nano** text editor is a basic example often preferred by those coming from a Windows environment. To open or create a file, use `nano filepath` or `nano -l filepath` to show line numbers. You can use the cursor keys to move around the text. Editor and file operations are completed using **CTRL**+ key shortcuts. For example, **CTRL+O** writes changes to the file and **CTRL+X** quits the editor.

Many administrators prefer to use **vi** or **vim**. These tools have two modes. Command mode is used for file operations, such as writing changes and closing the editor. To enter text, you need to switch to insert mode by pressing an appropriate command key. For example, `i` switches to insert mode at the current cursor position, a appends text after the current cursor position, `A` appends text at the end of the current line, and o inserts text on a new line below the current line. The **ESC** key switches from insert mode back to command mode.

To show line numbers, in command mode, enter `:set number`. To save a file, use `:w` from command mode. To save and quit, use `:wq`. Alternatively, :q! quits without saving.

# Navigation Commands
----

Everything available to Linux is represented as a file in a unified file system. For example, the first fixed disk would normally be represented in the file system by /dev/sda. A second storage device—perhaps one attached to a USB port—would be represented as /dev/sdb.

When Linux boots, a system kernel and virtual file system are loaded to a RAM drive. The unified file system identifies the location of the persistent root partition from the appropriate storage device and loads the file system stored on the disk.

Unlike Windows, Linux does not use drive letters like C: or D:. The unified file system starts at the root, represented by /. Directories and subdirectories can be created from the root to store files. Linux’s file system hierarchy standard (FHS) specifies how the directories under root should be named and where types of files should be placed. For example, the /home directory contains subdirectories for each user to store personal data and the /etc directory contains configuration files.

![](Meta/Pasted%20image%2020231020184619.png)

The core commands that you should know to navigate the Linux file system include pwd, cd, ls, and cat.

### pwd Command

pwd "prints" the working directory, though "printing" will typically mean “display on the terminal,” unless stdout is redirected. The working directory is important because any commands you use which don't specify a path as an argument will default to the working directory. The prompt on some distros will show your current working directory or the tilde (~), which indicates you are in your home directory.

### cd Command

`cd` is used to change the working directory. Typical syntax would be:

- Change directory to `/etc`. This is an absolute path from root (begins with /) so will work regardless of your current directory:

`cd /etc`

- Change your directory to a subdirectory called documents. This is a relative path. The **documents** directory must exist below the current directory:

cd documents

- Change your directory to the parent directory of the one you are currently working in:

`cd ..`

### cat Command

cat returns the contents of the files listed as arguments. The -n switch adds line numbers to the output. Often, cat output is piped to a pager (cat | more or cat | less) to control scrolling. You can also redirect the output to another file. In Linux, there are overwrite and append redirection operators:

- Overwrite any data at the destination file:

`cat > file`

- Append the cat data to the destination file:

`cat >> file`

You can use these redirection operators with other commands too.


# Search Commands
----

Linux supports very fast and accurate file system search commands.

### find Command

The find command is used to search for files. The basic syntax is `find path expression`, where _path_ is the directory in which to start the search and _expression_ is the data to match. An option is used to determine what the expression should search on, such as `-name`,` -size`, `-user` (owner), or` -perm` (permissions). The` -type` option locates classes of files, but where Windows file types are defined by extensions, in Linux, type distinguishes files, directories, block devices (disks), network sockets, symbolic links, and named pipes.


### grep Command

The grep (Globally search a Regular Expression and Print) command is used to search and filter the contents of files. Its output prints (displays) the lines that contain a match for the search string. The search string can be a simple text value to match (a literal) or can use a pattern-matching language called regular expressions (regex).

grep is especially useful for searching long files such as system logs. For example, the following command displays only the lines in the Linux system log file for messages that contain the text` uid=1003`, ignoring the case of the text with the -i switch:

`grep -i "uid=1003" /var/log/messages`

The grep command can also be used as a file name search tool by piping a directory list as input. For example, ls -l | grep audit command returns a long listing of any files in the current directory whose name contains audit.

	You can pipe the output of many other commands to grep to apply different types of filters.
	
### Metacharacters and Escaping

When writing expressions, you need to understand how to escape metacharacters. A metacharacter is one that is interpreted by the shell in a special way. When you write an expression, you might want asterisk ( * ) to match any number of any characters. This can be accomplished using the * metacharacter. If you want to find text that contains an asterisk character, you must escape it. Similarly, an expression that contains spaces (blanks) must be escaped.

There are three ways to escape strings:

- \ escapes the next character only. For example, \* treats * as a literal character; \\ treats \ as a literal character.
- Single quotes ( ' ' ) performs strong escaping. Everything within single quotes is treated as a literal character. For example, `‘$(pwd) * example one’` results in the expression:` $(pwd) * example one`
- Double quotes ( " " ) performs weak escaping. This escapes metacharacters but expands variables and allows a feature called command substitution. For example, "`$(pwd) * example one`" expands to use the output of the` pwd `command: `\home\david * example one`


# File Management Commands
----

File management commands are used to move, copy, and delete data.

### cp Command

cp is used to create a copy of files either in the same or different directory with the same or different name. For example:

- Copy file1.txt in the current working directory to a new file called file1.old in the same directory:

cp file1.txt file1.old

- Copy the file hosts from the directory /etc into the directory /tmp, keeping the file name the same:

cp /etc/hosts /tmp

- Copy all files beginning with the name message from the /var/log directory into /home/david. The -v option displays the files copied:

cp -v /var/log/message* /home/david

### mv Command

The mv command is used to either move files from one directory to another or rename a file. For example:

- Move the file data.txt from the /home/david directory to the /tmp directory, keeping the file name the same:

mv /home/david/data.txt /tmp

- Move and rename the file alarm.dat in the current directory to alarm.bak in /tmp:

mv alarm.dat /tmp/alarm.bak

- Rename the file app1.dat in the /var/log folder to app1.old:

mv /var/log/app1.dat /var/log/app1.old

### rm Command

The rm command can be used to delete files. It can also be used with the -r option to delete directories. For example:

- Remove the single file data.old from the current working directory:

rm data.old

- Remove all files ending in .bak from the /var/log directory:

rm /var/log/*.bak

- Remove the contents of the entire directory tree underneath the folder /home/david/data:

rm -r /home/david/data

	Use the -r switch with caution, and remember that Linux commands operate without confirmation prompts. There is no opportunity to cancel.

### df and du Commands

The df and du commands check free space and report usage by the device, directory, or file specified as the argument:

- df ("disk free") enables you to view the device's free space, file system, total size, space used, percentage value of space used, and mount point.
- du ("disk usage") displays how a device is used, including the size of directory trees and files within it.


# User Account Management
----

In Linux, the root user, also known as the superuser, is an administrative account with every available privilege. This account can do anything on the system. You should only use this account when absolutely necessary. Most Linux distributions prompt you to create a regular user account during guided setup. This is the user you should log on for day-to-day tasks. You can use special commands to temporarily elevate the privilege of this account rather than remaining logged in as root.

### su Command

The su (switch user) command switches to the account specified by username: su _username_. It is possible to switch to the superuser account by omitting the username argument. The command will prompt the user for the password of the target account before switching to it.

Using su without an option retains the original user's profile and variables. The switched user also remains in the home directory of the original user. Using su - changes to the root user and launches a new shell under the context of root. This is a better practice.

### sudo Command

The sudo (superuser do) command allows any account listed in the /etc/sudoers file user to run specified commands with superuser privilege level. In distributions that use sudo, this process is handled by guided setup. The user enters the sudo command followed by the command the user wishes to run. The user might be asked to confirm his or her password if it has not been cached recently. 

`The main advantage of sudo over su is that the root password does not have to be shared between multiple administrators.`

### User Management Commands

User settings are stored in the /etc/passwd file and group settings are stored in the /etc/group file. The user password is typically stored as an encrypted hash in the /etc/shadow file, along with other password settings, such as age and expiration date. The commands useradd, usermod, and userdel can be used to add, modify, and delete user information. The command passwd can be used to change the password.

### Group Management Commands

Each user account can be assigned to a group as a means of allocating permissions over files. The groupadd, groupmod, and groupdel commands can be used to manage group memberships.

A user can belong to many groups but can only have one effective group ID at any one time. The effective group ID is listed for the user account in /etc/passwd and can be changed using the newgrp command.

# File Permissions Commands
----

Each file has a set of permissions that determines the level of access for any given user. Linux uses a permissions system with three rights:

- Read (r) gives permission to view the contents of a file or directory.
- Write (w) gives permission to modify or delete the object. In the case of directories, this allows adding, deleting, or renaming files within the directory.
- Execute (x) gives permission to run an executable file or script. For directories, execute allows the user to do things such as change the focus to the directory and access or search items within it.

For each object, these permissions are set for the owner, for the group the owner belongs to or that the object has been assigned to, and for other users ("the world"). Using symbolic notation, each permission is allowed (r or w or x) or denied (-).

For example, if you run ls -l to obtain a long directory listing, the permissions will be shown as follows:

drwxr-xr-x 2 bobby admins Desktop

-rwx-r-x r-- 1 bobby admins scan.sh

The leading character designates the file type. For example, - represents a regular file and d indicates a directory. The permissions for the Desktop directory show that the owner (bobby) has full (rwx) permissions, whereas the group (admins) and others have read and execute but not write (r-x). For the scan.sh file, the user has read/write/execute (rwx) permission, the group has read and execute permission (r-x), and world has read permission only (r--).

Permissions can also be expressed numerically, using the octal value format. An octal value can represent up to eight digits (0–7). 0 represents deny (no permissions), read=4, write=2, and execute=1. You can add those values together to get a particular combination of permissions.

For example, a file with numeric permission 0754 can be converted to symbolic notation as follows:

- The leading zero identifies the value as an octal but can often be omitted.
- 7 in the first position grants all rights to the owner: 4(r)+2(w)+1(x).
- 5 in the second position grants read and execute to the group: 4(r)+0+1(x).
- 4 in the third position grants read to world: 4(r)+0+0.

The other common combination is 6 (read and write).

### chmod Command

The chmod command can be used to secure files and directories, using either symbolic or octal notation. Only the owner can change permissions.

![](Meta/Pasted%20image%2020231020190407.png)

### chown Command

The command chown allows the superuser to change the owner of a file or directory. Note that this right is reserved to superuser or sudoer. Even if a regular user owns a file, they cannot use chown. The file owner can change the group using the chgrp command.


# Package Management Commands
----

Linux software is made available both as source code and as pre-compiled applications. A source code package needs to be run through the appropriate compiler with the preferred options. Pre-compiled packages can be installed using a package manager. The choice of package manager is one of the basic distinctions between distro types:

- Advanced Packaging Tool (APT) is used by Debian distributions and works with .deb format packages.
- Yellowdog Updater, Modified (YUM) is used by Red Hat distributions and works with .rpm format packages.

### Distributions and Repositories

A distribution contains any precompiled software packages the vendor or sponsor considers appropriate. Copies of these packages (including any updates) will be posted to a software repository. Often the vendor will maintain different repositories. For example, there may be one for officially supported package versions, one for beta/untested versions, and one for "at own risk" unsupported packages.

The package manager needs to be configured with the web address of the software repository (or repositories) that you want to use. It can then be used to install, uninstall, or update the software. The repositories are configured automatically by the guided setup process.

![](Meta/Pasted%20image%2020231020190437.png)

The integrity of a package is usually tested by making a cryptographic hash of the compiled package, using a function such as MD5, SHA-256, or GNU Privacy Guard (GPG) signing. The hash value and function are published on the package vendor's site. The package manager validates the hash or signature before proceeding with an update or installation.

### apt-get Command

apt-get is a command interface for APT. The following basic commands are used to update/patch and install software.

- Refresh the local database with information about the packages available from the repository:

apt-get update

- Update all packages with the latest versions:

apt-get upgrade

- Install a new application:

apt-get install _PackageName_

	apt-get is an older means of interacting with APT at a terminal. The apt command tool is now the preferred means of doing this. apt uses identical sub-commands for these basic uses.

### yum Command

yum is the command interface for YUM. The following basic commands are used to update/patch and install software.

- Refresh the local database with information about the packages available from the repository:

yum check-update

- Update all packages with the latest versions:

yum update

- Install a new application:

yum install _PackageName_

### Antivirus

Some people feel that virus detection is unnecessary for Linux when used as a desktop PC OS. The way the Linux operating system is built (and the fact that there are many distributions) means that unlike Windows, it is harder to write a virus that will affect every Linux system. Different shells, a simpler security system, and software package managers with authorized software repositories all mean that a virus writer has a harder job to infect a Linux system.

This does not mean that Linux is risk-free, however, and each installation should be assessed for security controls to suit the use to which it is put. There have been several high-profile cases of either Trojans or serious vulnerabilities in software distributed through repositories or in popular third-party tools. Any high value target could be subject to specific, targeted attacks against it. Where Linux is used as the platform for a web server, for instance, it is imperative to configure appropriate security controls. Products such as Clam AntiVirus (ClamAV) and the Snort Intrusion Prevention System (IPS) can be used to block varied malware threats and attempts to counteract security systems. Though now owned by Cisco, both ClamAV and Snort are open-source products made freely available under the General Public License (GPL).

Another scenario for installing Linux anti-malware software is to detect infected files and prevent onward transmission via email or file transfer to Windows-based systems.

# Process Monitoring Commands
----

Every process is assigned a unique process ID (PID) when it is started so that the system and users can identify the process. This PID is a non-negative integer that increases for each new process that is started. PID 1 is allocated to the init daemon, which is the first process to start and is the parent of all other processes on the system. Processes started after this, whether by the system or by the user, are assigned a higher available number.

### ps Command

The ps command invokes the process table, a record that summarizes the current running processes on a system. When the command is run without any option, it displays the processes run by the current shell with details such as the PID, the terminal or pseudoterminal associated with the process, the accumulated CPU time, and the command that started the process. However, different options may be used along with the command to filter the displayed fields or processes.

![](Meta/Pasted%20image%2020231020190539.png)

### top Command

Like ps, the top command lists all processes running on a Linux system. It acts as a process management tool by enabling you to prioritize, sort, or terminate processes interactively. It displays a dynamic process status, reflecting real-time changes.
![](Meta/Pasted%20image%2020231020190551.png)

Different keystrokes within this tool execute various process management actions. Some of the frequently used command keys include the following.

- **ENTER** Refresh the status of all processes.
- **SHIFT+N** Sort processes in the decreasing order of their PID.
- **M** Sort processes by memory usage.
- **P** Sort processes by CPU usage.
- **u** Display processes belonging to the user specified at the prompt.
- **q** Exit the process list.

# Network Management Commands
----

In Linux, Ethernet interfaces are classically identified as eth0, eth1, eth2, and so on, although some network packages now use different schemes, such as en prefixes. In Linux, you need to distinguish between the running configuration and the persistent configuration. The persistent configuration is the one applied after a reboot or after a network adapter is reinitialized. The method of applying an IP configuration to an adapter interface is specific to each distribution.

Historically, the persistent configuration was applied by editing the /etc/network/interfaces file and bringing interfaces up or down with the ifup and ifdown scripts. Many distributions now use the NetworkManager package, which can be operated using a GUI or the nmcli tools. Alternatively, a network configuration might be managed using the systemd-networkd configuration manager.

### ip Command

When it comes to managing the running configuration, you also need to distinguish between legacy and current command packages. ifconfig is part of the legacy net-tools package. Use of these commands is deprecated on most modern Linux distributions. ifconfig can still safely be used to report the network interface configuration, however.

net-tools has been replaced by the iproute2 package. These tools can interface properly with modern network configuration manager packages. As part of the iproute2 package, the ip command has options for managing routes as well as the local interface configuration. The command ip addr replicates the basic reporting functionality of ifconfig (show the current address configuration). To report a single interface only, use ip addr show dev eth0. The ip link command shows the status of interfaces, while ip -s link reports interface statistics.

The ip link set eth0 up|down command is used to enable or disable an interface, while ip addr add|delete can be used to modify the IP address configuration. These changes are not persistent and apply only to the running configuration, unless run as part of a startup script.

### dig Command

dig is powerful tool for gathering information and testing name resolution. It is installed on most Linux distributions. Output is displayed in an answer section. Output will include the IP address mapped to the domain name, the DNS server that answered the query, and how long it took to receive that answer.

The basic syntax is: dig _domainame_

The command dig @_server domainname_ will resolve the domain name against the DNS server specified by the server argument.

### Samba

Linux has a Server Message Block (SMB)–compatible file sharing protocol called **Samba**. Samba enables the integration of Linux and Windows systems. When added to a Linux workstation, that workstation can use the Windows file and print sharing protocol to access shared resources on a Windows host. When the Samba service is added to a Linux server, the server uses the SMB protocol to share directories to Windows clients.


# Backup and Scheduling Commands
----

Linux does not have an "official" **backup** tool. You could create a custom backup solution using the crontask scheduler and file copy scripts. Backup could also use compression utilities, such as tar or gzip. There are plenty of commercial and open-source backup products for Linux, however. Some examples include Amanda, Bacula, Fwbackups, and Rsync.

If you want to run a batch of commands or a script to perform a backup or other maintenance task, there is a scheduling service called cron. Every user of the system is allowed to schedule programs or tasks in their own personal crontab (cron table). These tables are merged by cron to create an overall system schedule. Every minute, the cron service checks the schedule and executes the programs for that period.

- To add or delete a scheduled job, use the **crontab editor**. To review a user’s **crontab** jobs, enter the command:

crontab –l

- To remove jobs from the scheduled list, use the command:

crontab -r

- To enter the editor, run the command crontab –e. crontab uses the vi editor by default.

The basic syntax for scheduling a job using crontab includes the following:

- mm—specifies the minutes past the hour when the task is to initiate (0–59).
- hh—specifies the hour (0–23).
- dd—can be used to specify the date within the month (0–31).
- MM—specifies the month in either numerical or text format (1–12 or jan, feb, mar).
- weekday—sets the day of the week (1–7 or mon, tue, wed).
- command—the command or script to run. This should include the full path to the file.

It is important to note that any of the time/date related parameters can be replaced by wildcards:

- * specifies any or other characters.
- , allows multiple values.
- - allows a range of values.
- /2 indicates every other.

For example, consider the following crontab entry:

§ 15 02 * * 5 /usr/bin/rsync –av --delete /home/sam/mount/rsync

This would cause the system to run the rsync backup program at 2:15 a.m. on a Friday (day 5), synchronizing the /home/sam directory with the /mount/sync folder (which could be a mount point to an external backup device).

# Review Features of Linux
----

1. Which Linux command will display detailed information about all files and directories in the current directory, including system files?

ls -la

2. A command has generated a large amount of data on the screen. What could you add to the command to make the output more readable?

Either | more or | less.

3. What command would allow you to delete the contents of the folder /home/jaime/junk and all its subdirectories?

rm -r /home/jaime/junk

4. What command could you use to move a file names.doc from your current directory to the USB stick linked to folder /mnt/usb?

mv names.doc /mnt/usb

5. A file is secured with the numeric permissions 0774. What rights does another user account have over the file?

Read-only.

6. Which Linux command allows a user to run a specific command or program with superuser/root privileges?

sudo


